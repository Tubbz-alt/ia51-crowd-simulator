/* 
 * $Id$
 * 
 * Copyright (c) 2014-17 Stephane GALLAND <stephane.galland@utbm.fr>.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * This program is free software; you can redistribute it and/or modify
 */
package framework.^agent

import framework.^agent.action.PhysicEnvironmentCapacity
import framework.^agent.action.PhysicEnvironmentSkill
import framework.environment.DynamicType
import framework.environment.Influence
import framework.environment.Percept
import framework.environment.^event.SimulationAgentReadyEvent
import framework.environment.^event.StopSimulationEvent
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import java.util.List
import java.util.UUID
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import org.arakhne.afc.math.geometry.d2.d.Point2d

abstract agent AbstractAnimat {
	
	uses PhysicEnvironmentSkill, Lifecycle, DefaultContextInteractions
	
	var behaviorType : DynamicType
	var pos : Point2d
	var ori : Vector2d
	
	/** Change the type of the behavior.
	 */
	def setBehaviorType(type : DynamicType) {
		this.behaviorType = type
	}

	/** Replies the type of the behavior.
	 */
	def getBehaviorType() : DynamicType {
		this.behaviorType
	}

	def overridableInitializationStage(it : Initialize) : void {
		var physicSkill = new PhysicEnvironmentSkill(it.parameters.get(0) as UUID,
			it.parameters.get(1) as UUID)
		this.behaviorType = it.parameters.get(2) as DynamicType
		setSkill(physicSkill, typeof(PhysicEnvironmentCapacity))
	}
	
	def getMaxLinear(p : Percept) : double {
		if (this.behaviorType == DynamicType::STEERING) p.maxLinearAcceleration else p.maxLinearSpeed
	}
	
	def getMaxAngular(p : Percept) : double {
		if (this.behaviorType == DynamicType::STEERING) p.maxAngularAcceleration else p.maxAngularSpeed
	}

	def emitInfluence(output : MotionAlgorithmOutput, influences : Influence*) {
		if (output !== null) {
			if (output.getType() === DynamicType::STEERING)
				influenceSteering(output.linear, output.angular, influences)
			else
				influenceKinematic(output.linear, output.angular, influences);
		} else {
			influenceSteering(new Vector2d, 0.0, influences)
		}
	}
	
	def doNothing {
		influenceKinematic(new Vector2d, 0.0)
	}

	def first(list : List<Percept>) : Percept {
		if (list.isEmpty) null else list.get(0)
	}

	def getPos() : Point2d {
		pos
	}

	def getOri() : Vector2d {
		ori
	}

	def setPos(newPos : Point2d) {
		pos = newPos
	}

	def setOri(newOri : Vector2d) {
		ori = newOri
	}

	/** When a FimuGoer goes to another agent, it is systematically to retrieve something from it. This is the retrieval function.
	 * Despite being very ugly because of the FimuGoer reference in a parent class, this the only way I have found to design this method.
	 * 
	 * There are several types of instanciable agents: FimuGoers, FoodStands, DrinkStands, Scenes, etc.
	 * Each one of them gives something when interacted with by other agents.
	 * FoodStands give food, DrinkStands give drinks, Scenes give music, and FimuGoers give conversation.
	 * But they can only give stuff to FimuGoers, and FimuGoers are the only agents to have the required methods in order to be given something.
	 * They cannot be generalized to a simple Agent for that operation, hence that dirty reference.
	 */
	def abstract getSomething(caller : FimuGoer)

	on Initialize {
		occurrence.overridableInitializationStage
		emit(new SimulationAgentReadyEvent)
	}

	on StopSimulationEvent {
		killMe
	}
}