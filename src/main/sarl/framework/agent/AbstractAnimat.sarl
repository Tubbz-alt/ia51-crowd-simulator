/* 
 * $Id$
 * 
 * Copyright (c) 2014-17 Stephane GALLAND <stephane.galland@utbm.fr>.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * This program is free software; you can redistribute it and/or modify
 */
package framework.^agent

import framework.^agent.action.PhysicEnvironmentCapacity
import framework.^agent.action.PhysicEnvironmentSkill
import framework.environment.DynamicType
import framework.environment.Influence
import framework.environment.Percept
import framework.environment.^event.SimulationAgentReadyEvent
import framework.environment.^event.StopSimulationEvent
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import java.util.List
import java.util.UUID
import org.arakhne.afc.math.geometry.d2.d.Vector2d

agent AbstractAnimat {
	
	uses PhysicEnvironmentSkill, Lifecycle, DefaultContextInteractions
	
	var behaviorType : DynamicType
	
	on Initialize {
		occurrence.overridableInitializationStage
		emit(new SimulationAgentReadyEvent)
	}

	/** Change the type of the behavior.
	 *
	 * @param type the type.
	 */
	def setBehaviorType(type : DynamicType) {
		this.behaviorType = type
	}

	/** Replies the type of the behavior.
	 * 
	 * @param type the type.
	 */
	def getBehaviorType() : DynamicType {
		this.behaviorType
	}

	def overridableInitializationStage(it : Initialize) : void {
		var physicSkill = new PhysicEnvironmentSkill(it.parameters.get(0) as UUID,
			it.parameters.get(1) as UUID)
		this.behaviorType = it.parameters.get(2) as DynamicType
		setSkill(physicSkill, typeof(PhysicEnvironmentCapacity))
	}
	
	def getMaxLinear(p : Percept) : double {
		if (this.behaviorType == DynamicType::STEERING) p.maxLinearAcceleration else p.maxLinearSpeed
	}
	
	def getMaxAngular(p : Percept) : double {
		if (this.behaviorType == DynamicType::STEERING) p.maxAngularAcceleration else p.maxAngularSpeed
	}

	def emitInfluence(output : MotionAlgorithmOutput, influences : Influence*) {
		if (output !== null) {
			if (output.getType() === DynamicType::STEERING)
				influenceSteering(output.linear, output.angular, influences)
			else
				influenceKinematic(output.linear, output.angular, influences);
		} else {
			influenceSteering(new Vector2d, 0.0, influences)
		}
	}
	
	def doNothing {
		influenceKinematic(new Vector2d, 0.0)
	}

	def first(list : List<Percept>) : Percept {
		if (list.isEmpty) null else list.get(0)
	}

	on StopSimulationEvent {
		killMe
	}

}