/** 
 * 
 */
package io.sarl.fimu.environment

import java.util.ArrayList
import java.util.Collection
import java.util.Collections
import java.util.List
import java.util.Map
import java.util.TreeMap
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean
import org.arakhne.afc.math.MathConstants
import org.arakhne.afc.math.geometry.d2.d.Circle2d
import org.arakhne.afc.math.geometry.d2.d.Point2d
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import org.arakhne.afc.math.tree.node.QuadTreeNode

/** 
 * @author LÃ©on
 * Main Environment class. It is supposed to hold and manage all the agents
 */
class Environment {

	val width : double
	val height : double
	
	var init = false
	
	static val NORMAL_PERSON_SIZE = 20.0
	val stateChanged = new AtomicBoolean

	new (width : double, height : double) {
		this.width = width
		this.height = height
		//this.timeManager = timeManager
	}
	
	new {
		this.width = 700.0
		this.height = 700.0
	}
	
	var model = new QuadTreeNode.DefaultQuadTreeNode<ISituatedObject>
	val agentBodyList : Map<UUID, AgentBody> = new TreeMap
	
	
	def getAgentBody(id : UUID) : AgentBody {
		synchronized (this.agentBodyList) {
			this.agentBodyList.get(id)
		}	
	}

	def getAgentBodies : Iterable<AgentBody> {
		synchronized (this.agentBodyList) {
			return Collections.unmodifiableCollection(this.agentBodyList.values)
		}
	}
	
	def getAllObjects : Iterable<? extends ISituatedObject> { model.allUserData }
	
	def applyInfluences(motionInfluences : Collection<MotionInfluence>) {
		
		var influenceList = new ArrayList(motionInfluences)
		var actions = new ArrayList<AnimatAction>(influenceList.size)
		
		for (index1 : 0 ..< influenceList.size) {
			var inf1 = influenceList.get(index1)
			var body1 = getAgentBody(inf1.emitter)
			if (body1 !== null) {
				var move : Vector2d
				var rotation : double
				if (inf1.type === DynamicType::STEERING) {
					move = body1.computeSteeringTranslation(inf1.linearInfluence/*, timeManager*/)
					rotation = body1.computeSteeringRotation(inf1.angularInfluence/*, timeManager*/)
				} else {
					move = body1.computeKinematicTranslation(inf1.linearInfluence/* , timeManager*/)
					rotation = body1.computeKinematicRotation(inf1.angularInfluence/* , timeManager*/)
				}

				var body1Bounds = body1.shape

				// Trivial collision detection
				//trivialCollisionDetection(index1, influenceList, body1Bounds, move)

				actions += new AnimatAction(body1, move, rotation)

			}
		}

		// Apply the actions
		for (action : actions) {
			var body = action.objectToMove
			if (body !== null) {
				body.move(action.translation, action.rotation)
			}
		}

	}

	def runBehavior {
//		if (this.init.getAndSet(false)) {
//			fireEnvironmentChange
//		}

		this.stateChanged.set(false)

		var motionInfluences = new ArrayList<MotionInfluence>
		var otherInfluences = new ArrayList<Influence>
		var bodies : List<AgentBody>
		synchronized (this.agentBodyList) {
			bodies = new ArrayList(this.agentBodyList.size)
			bodies.addAll(this.agentBodyList.values)
		}
		for(body : bodies) {
			var mi = body.consumeMotionInfluence
			if (mi !== null) {
				motionInfluences += mi
			}
			for (i : body.consumeOtherInfluences) {
				if (i instanceof KillInfluence) {
					stateChanged()
					var rbody : AgentBody
					synchronized (this.agentBodyList) {
						rbody = (this.agentBodyList -= i.emitter)
					}
					if (rbody !== null) {
						rbody.onAgentBodyDestroyed
					}
				} else {
					otherInfluences += i
				}
				}
		}
		
		}

	def onAgentBodyCreated(body : AgentBody) {
		this.model.addUserData(body)
	}

	def onAgentBodyDestroyed(body : AgentBody) {
		this.model.removeUserData(body)
	}
	
	protected final def computeSteeringTranslation(obj : IMobileObject, move : Vector2d/*, clock : TimeManager*/) : Vector2d {
		if (obj instanceof AbstractMobileObject) {
			return obj.computeSteeringTranslation(move/*, clock*/)
		}
		throw new IllegalArgumentException("obj") 			// $NON-NLS-1$
	}

	protected final def computeKinematicTranslation(obj : IMobileObject, move : Vector2d/*,	clock : TimeManager*/) : Vector2d {
		if (obj instanceof AbstractMobileObject) {
			return obj.computeKinematicTranslation(move/*, clock*/)
		}
		throw new IllegalArgumentException("obj") 	// $NON-NLS-1$
	}
	
	protected final def computeKinematicRotation(obj : IMobileObject, move : double/*, clock : TimeManager*/) : double {
		if (obj instanceof AbstractMobileObject) {
			return obj.computeKinematicRotation(move/*, clock*/)
		}
		throw new IllegalArgumentException("obj") 	// $NON-NLS-1$
	}

	protected final def move(obj : IMobileObject, instantTranslation : Vector2d, instantRotation : double) {
		if (obj instanceof AbstractMobileObject) {
			//var duration = this.timeManager.lastStepDuration
			obj.move(instantTranslation.x, instantTranslation.y/*, duration*/, this.width, this.height)
			obj.rotate(instantRotation/*, duration*/)
			stateChanged()
		} else {
			throw new IllegalArgumentException("obj")
		}
	}

	protected def stateChanged {
		this.stateChanged.set(true)
	}

	private def createBody(type : String) {
		var body = new AgentBody(UUID::randomUUID, 
								 new Circle2d(0.0, 0.0, NORMAL_PERSON_SIZE), // body
								 5.0, // max linear speed m/s
							 	 0.5, // max linear acceleration (m/s)/s
								 MathConstants::PI / 4.0, // max angular speed r/s
								 MathConstants::PI / 10.0, // max angular acceleration (r/s)/s
								 null); // no frustum since computePerceptionsFor() is not using this parameter
		//body.name = MessageFormat::format("Body #{0}", this.agentBodyNumber + 1)
		body.type = type
		addAgentBody(body, randomPosition, Math::random as double * MathConstants::TWO_PI)
	}
	
	def createPelo(){
		createBody("PELO")
	}

	protected def randomPosition : Point2d {
		var x = Math::random as double * this.width - NORMAL_PERSON_SIZE
		var y = Math::random as double * this.height - NORMAL_PERSON_SIZE
		return new Point2d(x, y)
	}

	protected synchronized def addAgentBody(body : AgentBody, position : Point2d, direction : double) {
		if (true) {
			synchronized (this.agentBodyList) {
				this.agentBodyList.put(body.id, body)
			}
			body.position = position
			body.angle = direction
			body.onAgentBodyCreated
		} else {
			throw new IllegalStateException("You cannot call this function after the start of the simulation");
		}
	}

	def getAgentBodyNumber : int {
		synchronized (this.agentBodyList) {
			return this.agentBodyList.size
		}
	}
}
